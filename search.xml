<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AngularJS项目前后端对接时遇到的传参问题]]></title>
    <url>%2F2017%2F07%2F26%2FAngularJS%E9%A1%B9%E7%9B%AE%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 今天在和后端进行对接的时候，遇到了一个很奇怪的 bug : 一个POST请求，参数里必要的字段，格式和请求的地址都是正确的，但是一直报400错误 先说结论： 调了很久最后发现是 Request body里的参数，即使不是必需的，也得带上，否则就会报请求错误 的问题。 具体过程让我们一起来探讨： 错误描述在 daprest-api 接口处直接进行数据测试，是可行的，说明后端的逻辑没有问题【图一】【图二】 但是本地运行，执行 http 请求的时候12345678910111213141516171819202122232425// 废除操作$scope.delete = function() &#123; console.log("废除时的参数：projectId:" + projectId + ' taskId:' + taskId + ' activityName:' + activityName); console.log("projectID 类型"+typeof(projectId)); console.log("url: "+projectConstant.project.blankout); Dhttp.http(&#123; //url: projectConstant.project.blankout+'?projectId='+projectId+'&amp;taskId='+taskId+'&amp;activityName='+activityName, url: projectConstant.project.blankout, method: "POST", params: &#123; projectId: projectId, taskId: taskId, activityName: activityName &#125; &#125;).then(function() &#123; layer.alert('废除成功！', &#123; skin: 'layui-layer-lan' ,closeBtn: 0 ,anim: 4 //动画类型 &#125;); setTimeout(function () &#123; $rootScope.$broadcast('verifyForm:delele', ''); &#125;, 500); &#125;);&#125; 结果：【图三】通过仔细的对比，我尝试了几种方法： 解决方法是参数的数据类型问题吗？ 如图： projectId 和 taskId 的数据类型要求为 Integer 而本地1console.log("projectID 类型"+typeof(projectId)); 结果为 string,于是12var projectId = parseInt($stateParams.projectId);var taskId = parseInt($stateParams.taskId); 将其转化成 number，结果： 失败，依旧是 400 错误。 是参数的传入顺序问题吗？对比【图一】和【图三】，在 Request Header里的 第一部分 General里发现，测试中的url 参数顺序是 ?projectId=245&amp;taskId=522&amp;activityName=%E7%99%BB%E8%AE%B0; Request URL: 里的后半部分 ?activityName=%E7%99%BB%E8%AE%B0&amp;projectId=245&amp;taskId=522 参数顺序不一样，于是我强制让参数顺序统一 1url: projectConstant.project.blankout+'?projectId='+projectId+'&amp;taskId='+taskId+'&amp;activityName='+activityName, 结果： 失败，依旧是 400 错误。 是参数的请求方法问题吗？直觉上应该不是这个问题，但是死马当活马医了，尝试将 method 方法由 POST 改成 GET。1234567url: projectConstant.project.blankout,method: "GET",params: &#123; projectId: projectId, taskId: taskId, activityName: activityName&#125; 结果： 失败，依旧是 400 错误。。。喝口水冷静一下，继续想。 是少传了参数的问题吗？因为在 daprest-api 上进行测试，填了必填项，是可以成功的，其他参数肯定是默认为空的，会不会是本地也需要传呢？ 马上进行测试1234567891011url: projectConstant.project.blankout,method: "POST",data: &#123; reason: ''&#125;,params: &#123; projectId: projectId, taskId: taskId, activityName: activityName, xmId: ''&#125; 结果： 成功！ 之后再进行了一次测试，发现 xmId: &#39;&#39; 是可以省略的，重要的是处于 body 里的 reason 字段 即使为空，即使不是必填项，也需要带上，才算是一个完整的 POST 请求 后记这个问题是第一次遇到，很有价值，希望之后遇到同样问题的朋友能发现我这篇文章，解决 bug。 (๑╹◡╹)ﾉ”””]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
        <tag>前后端对接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于博客的一点想法和改进]]></title>
    <url>%2F2017%2F07%2F25%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95%E5%92%8C%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 今天突然想到，天天写这些教程类的博客，真的有作用吗？ 阮一峰说过，他写博客，是因为自己不懂，所以自己学习之后，再写成文章。 我觉得我有些本末倒置了，只是想着帮助别人通过我的博客了解知识，却忽略了自己，说真的，这么多篇博客，我自己的确也学到了东西，但是与付出的时间却是不成正比的，有些东西其实是我自己用不到的。。。而且，换个角度，也许我写的教程类博客其实并没有很多人看，因此，也达不到我最初想要的效果。 所以，我做出了一个决定，将博客进行转型，成为 问题导向型博客，记录自己在学习过程遇到的问题，感想，经验以及教训，而不只是一个教程类的博客（我的生活感想和记录也会加入进来，这样，才是一个完整的博客嘛(๑╹◡╹)ﾉ”””）。这样，我和看我博客的朋友们，都能学到更多的东西。 把时间用在正确的地方，多去探索自己不会的知识，而不是去炒冷饭。身边的人都那么优秀，我也必须变得优秀才行，不要再贪玩了，别忘了自己的梦想！]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>想法</tag>
        <tag>改进</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-7-22 上海Bilibili World漫展后记]]></title>
    <url>%2F2017%2F07%2F22%2F2017-7-22-%E4%B8%8A%E6%B5%B7Bilibili-World%E6%BC%AB%E5%B1%95%E5%90%8E%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 今天，参加了 B站 举办的 Bilibili World 线下交流会（漫展），具体的介绍见lex的视频 PS: 官网的效果炒鸡酷炫，官网：https://bml.bilibili.com/2017/index.html#/home作为一个动漫迷，中二又有点小宅的我来说，参加一次漫展，是我的愿望之一，但是一直没有找到机会，前几天看到出了这个活动，立马就入手了，几乎没有给自己考虑的时间，因为我知道这次不能错过。今天去了之后，我觉得，值了！٩(๑&gt;◡&lt;๑)۶ v 早上7点左右起床，赶往上海世博馆，10点开始，我很幸运地刚好赶上，没有排很久的队，在去的路上，就看到了很多coser, 心情还是有点小激动的，毕竟是第一次参加，而且，看到那么多和自己有相同爱好的朋友，能不激动吗？(≧▽≦)/这是入场前拍到的几位coser的照片 外面真的超级热，进场前和进场后，小电视的形态告诉我们： 有空调和没空调的区别 进场之后，人超级多，但是空调很给力，还是很舒适的，看到了很多 22和33 的展板，不得不说 B站 的画师真的超级厉害啊，很漂亮~ 看图 还有很多coser，他/她们也都很愿意拍照或者合影，我拍了很多照片（没太敢合影，因为我不太会自拍，而且出发前没洗头。。。另外求推荐一款好的自拍软件，手机自带的拍的不好看）一大波照片即将来袭… 还有大触的画 按照进场时拿到的手册，应该有7个游戏的，但是，人太多了，排队都不知道要排到什么时候，所以就只能看其他人玩了，不过，挺有趣的，说到这里，有一个必须得说一下，那就是黑白键舞台，坐镇的是 KyleXian 大大，现场观众随机点，只要他会的，立马就能弹出来（就我在那里听的那段时间，他没有卡壳过，全都弹出来了！！！这就是大触哇Σ(っ°Д°;)っ）我点了一首 “宾克斯的美酒” 作为海贼死忠粉，这个当然是必点的，这里是 录的视频网盘地址 （K大好像弹得不是完整版，而是类似串烧的，这首后面结尾的部分有点怪 ）附上K大自己整理之后投稿视频~ 另外，lovelive sunshine! 的团队也来到了现场，我感受到了宅男们的欢呼，真的出乎我的意料（这就是死宅们的力量吗？ ）不过，妹子们的声音都好萌哇！！！我比较喜欢热血漫，对这类萌系动漫不是特别感冒，不过，来者不拒 因为现场工作人员不准拍照，我就录了一段音频，这里是音频地址 感受死宅们的呐喊吧 （我没喊，因为没看过 lovelive，不过我很理解他们，毕竟是自己喜欢的东西，我想，如果海贼王的声优来了的话，我肯定会比他们更疯狂！） 转了一天，也真的站了一天，座位很少，很多人累了就只能靠墙坐下来休息，里面只有一家麦当劳炸鸡，排着很长很长的队，辛亏我查了攻略，自己带了水和食物。总的来说，今天是超级开心的，下次如果有机会，我一定会再来！ 最后，不要忘了： 哦，对了，说一下应该注意的事情吧： 一定要带把伞，无论是大太阳，还是下雨，都很有用处。 要带些食物和水，不宜太多（我带了三瓶水，背了一天，只喝了一瓶，累死）。 出发前查好攻略，包括路线，场内布局，对你感兴趣的舞台，提前了解开始时间。 不要害羞，大胆的去玩，去合影（手机里要有一个靠谱点的自拍软件，如果有自拍杆更好）很多coser人都很好，大胆地去求合影吧骚年！ 下次传大量图片的时候，千万不要用QQ。。。直接用网盘]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>漫展</tag>
        <tag>Bilibili World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angularJS 的安全验证机制]]></title>
    <url>%2F2017%2F07%2F20%2FangularJS%E7%9A%84%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” AngularJS的安全认证AngularJS 通过 $SCE，即 strict contextual escaping ，应该是angularjs严格的控制上下文访问。 由于angular默认是开启SCE的，因此也就是说默认会决绝一些不安全的行为，比如你使用了某个第三方的脚本或者库、加载了一段html等等。 这样做确实是安全了，避免一些跨站XSS，但是有时候我们自己想要加载特定的文件，这时候怎么办呢？此时可以通过 $sce 服务把一些地址变成安全的、授权的链接…简单地说，就像告诉门卫，这个陌生人其实是我的好朋友，很值得信赖，不必拦截它！ 常用的方法有：12345$sce.trustAs(type,name);$sce.trustAsHtml(value);$sce.trustAsUrl(value);$sce.trustAsResourceUrl(value);$sce.trustAsJs(value); 其中后面的几个都是基于第一个api使用的，比如trsutAsUrl其实调用的是trsutAs($sce.URL,”xxxx”); 其中type可选的值为： $sce.HTML $sce.CSS $sce.URL //a标签中的href ， img标签中的src $sce.RESOURCE_URL //ng-include,src或者ngSrc，比如iframe或者Object $sce.JS 来自官网的例子：ng-bind-html123456789101112&lt;div ng-controller="AppController"&gt; &lt;i ng-bind-html="explicitlyTrustedHtml" id="explicitlyTrustedHtml"&gt;&lt;/i&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; angular.module('mySceApp',[]) .controller('AppController', ['$scope', '$sce', function($scope, $sce) &#123; $scope.explicitlyTrustedHtml = $sce.trustAsHtml( '&lt;span onmouseover="this.textContent=&amp;quot;Explicitly trusted HTML bypasses ' + 'sanitization.&amp;quot;"&gt;Hover over this text.&lt;/span&gt;'); &#125;]);&lt;/script&gt; 实际工作中的例子：ng-src链接12345678910&lt;div ng-controller="AppController"&gt; &lt;iframe width="100%" height="100%" seamless frameborder="0" ng-src="&#123;&#123;trustSrc&#125;&#125;"&gt;&lt;/iframe&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; angular.module('mySceApp',[]) .controller('AppController', ['$scope','$sce',function($scope,$sce) &#123; $scope.trustSrc = $sce.trustAs($sce.RESOURCE_URL,"http://fanyi.youdao.com/"); // $scope.trustSrc = $sce.trustAsResourceUrl("http://fanyi.youdao.com/");//等同于这个方法 &#125;]); &lt;/script&gt;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
        <tag>安全机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何配置一个合格的gulpfile文件?]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%90%88%E6%A0%BC%E7%9A%84gulpfile%E6%96%87%E4%BB%B6%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 配置 gulp 一些最基本的，必要的安装 nodeJS ，配置环境我就不赘述了，详情可以看一下这两篇博客菜鸟教程Node.js 安装配置CSDN博客NodeJS、NPM安装配置步骤(windows版本) 前语(为什么选择 gulp 而不是 grunt)Grunt.js和Gulp.js工作方式的区别。Grunt主要是以 文件 为媒介来运行它的工作流Grunt执行完一项任务之后，分为四步， 第一步会把结果写入到一个 临时文件 中 之后再在这个 临时文件 内容的基础上执行其它任务 执行完成后再把结果写入到 临时文件 中 然后又以这个为基础继续执行其它任务…就这样反复下去Gulp中，使用的是Nodejs中的stream(流)首先获取到需要的 stream ，然后可以通过 stream 的 `pipe() 方法把流导入到你想要的地方，比如 Gulp 的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。 所以Gulp是以stream为媒介的，它不需要频繁的生成 临时文件，这也是Gulp的速度比Grunt快的一个原因。 基础步骤全局安装 gulp在 git 命令行下输入1npm install gulp -g tips: 如果网速比较慢，可以采用cnpm1npm install cnpm -g --registry=https://registry.npm.taobao.org 项目安装 gulp 以及 gulp 插件1cnpm install gulp gulp-uglify gulp-clean-css gulp-imagemin gulp-load-plugins gulp-rename gulp-minify-html gulp-jshint gulp-concat gulp-less gulp-sass browser-sync gulp-clean gulp-babel --save-dev 这些插件的用处后面会简要介绍，一般常用的就这些，细心的朋友可能会发现，全局安装了 gulp ，为什么项目根目录下还要再装一次呢？有兴趣的可以看下 stackoverflow 上有人做出的回答：why-do-we-need-to-install-gulp-globally-and-locally、what-is-the-point-of-double-install-in-gulp。就是为了版本的灵活性以及可部署性，引用官方的一段描述 “The reason this works is because gulp tries to run your gulpfile.js using your locally installed version of gulp, see here. Hence the reason for a global and local install of gulp.” 意思就是 gulp 运行 gulpfile.js 调用的是项目本地的某一个 gulp 版本。其实很好理解，因为可能你和别人全局装的 gulp 版本是不一样的，但是，如果项目里也装了 gulp ，一致用项目中的 gulp, 就不会出现版本冲突的问题了。同时，由于是直接访问，不用向外层去寻找 gulp ，效率得以提升。 “When used in a script field of your package.json, npm searches node_modules for the tool as well as globally installed modules, so the local install is sufficient.” 配置gulpfile.js就像gruntjs需要一个Gruntfile.js文件一样，gulp也需要一个文件作为它的主文件。 首先，在命令行下，npm init ，就会出现输入配置信息的选项（也可以直接自己建），然后，新建 gulpfile.js (命名也可以改成 index.js,这里提供一个较为完整的模板)123var gulp = require('gulp');//加载gulp-load-plugins插件，并马上运行它var plugins = require('gulp-load-plugins')(); 项目的目录结构我使用的项目结构(我自己也一直在找一个好的项目目录结构，这个借鉴于Angular系列学习笔记（二）—— 基于gulp构建Angular单页面应用, 很不错的一个目录结构) ├── node_modules // 打包过程中依赖的包 ├── package.json // 包含各种所需模块以及项目的配置信息 ├── gulpfile.js // 打包配置文件 ├── app // 打包之后最终部署到服务器上的文件（名称自定义） ├── src // 资源文件（名称自定义） ├── components // 自定义全局组件 ├── pageloading （如：页面切换loading） ... ├── pages // 页面路由组件 ├── index ├── index.jade 默认路由视图 ├── index.controller.js 默认路由控制器 └── index.config.js 默认视图路由配置 ├── etc ··· ├── assets // 静态资源 ├── images // 图片资源 ├── app.module.js // 全局模块 ├── index.jade // 入口视图模板 └── index.less // 入口视图样式 └── vendor.config.js // 依赖的库配置文件（自定义） 运行 gulp 任务要运行 gulp 任务，只需切换到存放 gulpfile.js 文件的目录( windows 平台请使用 cmd 或者 Power Shell 等工具)，然后在命令行中执行 gulp 命令就行了，gulp 后面可以加上要执行的任务名，例如 gulp task1，如果没有指定任务名，则会执行任务名为 default 的默认任务。 gulp里的几个API其实，只需要知道4个就OK, gulp.task(), gulp.src(), gulp.dest(), gulp.watch() ,基本上最常用的就是这四个 gulp.src()gulp.src()方法正是用来获取流的，但是 注意: 这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息. 我们只需简单的理解可以用这个方法来读取需要操作的文件就行了, 函数需要的参数如下1gulp.src(globs[, options]) globs参数是文件匹配模式(类似 正则表达式 )，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径. * 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾 ** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。 ? 匹配文件路径中的一个字符(不会匹配路径分隔符) [...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法 !(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的 ?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的(pattern|pattern|pattern)? +(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+ *(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)* @(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern) 举些例子就好理解了 * 能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js *.* 能匹配 a.js,style.css,a.b,x.y */*/*.js 能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js ** 能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,能用来匹配所有的目录和文件 **/*.js 能匹配 foo.js,a/foo.js,a/b/foo.js,a/b/c/foo.js a/**/z 能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/z a/**b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录 ?.js 能匹配 a.js,b.js,c.js a?? 能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符 [xyz].js 只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符 [^xyz].js 能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js 当有多种匹配模式时可以使用数组12//使用数组的方式来匹配多种文件gulp.src(['js/*.js','css/*.css','*.html']) 使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上!即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式 12gulp.src([*.js,'!b*.js']) //匹配所有js文件，但排除掉以b开头的js文件gulp.src(['!b*.js',*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中 此外，还可以使用展开模式。展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式相加起来得到的结果。展开的例子如下： a{b,c}d 会展开为 abd,acd a{b,}c 会展开为 abc,ac a{0..3}d 会展开为 a0d,a1d,a2d,a3d a{b,c{d,e}f}g 会展开为 abg,acdfg,acefg a{b,c}d{e,f}g 会展开为 abdeg,acdeg,abdeg,abdfg 小例子1234var gulp = reruire('gulp');//有通配符开始出现的那部分路径为 **/*.jsgulp.src('script/**/*.js') .pipe(gulp.dest('dist')); gulp.dest()含义解释gulp.dest()方法是用来写文件的，其语法为：1gulp.dest(path[,options]) path 为写入文件的路径, options 为一个可选的参数对象，通常我们不需要用到。 gulp.dest() 给它传入的路径参数与最终生成的文件的关系。 通过 gulp.src() 方法获取到我们想要处理的文件流 把文件流通过 pipe 方法导入到 gulp 的插件中 把经过插件处理后的流再通过 pipe 方法导入到 gulp.dest() 中 gulp.dest()方法则把流中的内容写入到文件中 注意: 我们给gulp.dest()传入的路径参数，只能用来指定要 生成的文件的目录 ，而不能指定生成文件的文件名，它生成文件的文件名使用的是 导入到它的文件流自身的文件名，所以 gulp.dest()传入的路径参数，只能用来指定要 生成的文件的目录,生成的文件名是由导入到它的文件流决定的 要想改变文件名，可以使用插件 gulp-rename. 路径名称的生成gulp.dest(path) 生成的文件路径是我们传入的 path 参数后面再加上 gulp.src() 中有通配符开始出现的那部分路径。看完下面几个例子就知道了~ 1234567891011121314151617var gulp = reruire('gulp');//有通配符开始出现的那部分路径为 **/*.jsgulp.src('script/**/*.js') .pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/**/*.js//如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.jsgulp.src('script/avalon/avalon.js') //没有通配符出现的情况 .pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/avalon.js//有通配符开始出现的那部分路径为 **/underscore.jsgulp.src('script/**/underscore.js') //假设匹配到的文件为script/util/underscore.js .pipe(gulp.dest('dist')); //则最后生成的文件路径为 dist/util/underscore.jsgulp.src('script/*') //有通配符出现的那部分路径为 * //假设匹配到的文件为script/zepto.js .pipe(gulp.dest('dist')); //则最后生成的文件路径为 dist/zepto.js gulp.task()含义解释gulp.task方法用来定义任务，内部使用的是 Orchestrator，其语法为：1gulp.task(name[, deps], fn) name 为任务名 deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数 fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。如下123gulp.task('mytask', ['one', 'two', 'three', 'four'], function() &#123; //定义一个有依赖的任务 // Do something&#125;); 重点： 任务执行的顺序问题gulp中执行多个任务，可以通过任务依赖来实现。例如我想要执行one,two,three这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：12//只要执行default任务，就相当于把one,two,three这三个任务执行了gulp.task('default',['one','two','three']); 如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。 但是如果某个任务所依赖的任务是异步的，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务123456789101112gulp.task('one',function()&#123; //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done') &#125;,5000);&#125;);//two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;);// 会先输出 two is done 有三种方法可以实现：执行一个回调函数在异步操作完成后执行一个回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数。123456789101112gulp.task('one',function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done'); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;);//这时two任务会在one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况。12345678910gulp.task('one',function(cb)&#123; var stream = gulp.src('client/**/*.js') .pipe(dosomething()) //dosomething()中有某些异步操作 .pipe(gulp.dest('build')); return stream;&#125;);gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 返回一个promise对象12345678910111213var Q = require('q'); //一个著名的异步处理的库 https://github.com/kriskowal/qgulp.task('one',function(cb)&#123; var deferred = Q.defer(); // 做一些异步操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 5000); return deferred.promise;&#125;);gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); gulp.task()就这些了，主要是要知道当依赖是 异步任务 时的处理。 gulp.watch()gulp.watch() 用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为1gulp.watch(glob[, opts], tasks) glob 为要监视的文件匹配模式，规则和用法与 gulp.src()方法中的 glob 相同。 opts 为一个可选的配置对象，通常不需要用到 tasks 为文件变化后要执行的任务，为一个数组 1234567gulp.task('uglify',function()&#123; //do something&#125;);gulp.task('reload',function()&#123; //do something&#125;);gulp.watch('js/**/*.js', ['uglify','reload']); gulp.watch()还有另外一种使用方式：1gulp.watch(glob[, opts, cb]) glob 和 opts 参数与第一种用法相同 cb 参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径 1234gulp.watch('js/**/*.js', function(event)&#123; console.log(event.type); // 变化类型 added 为新增, deleted 为删除，changed 为改变 console.log(event.path); // 变化的文件的路径&#125;); 几个比较好的 gulp 插件自动加载插件使用 gulp-load-plugins1npm install gulp-load-plugins --save-dev 要使用gulp的插件，首先得用require来把插件加载进来，如果我们要使用的插件非常多，那我们的gulpfile.js文件开头可能就会是这个样子的：1234567891011var gulp = require('gulp'), //一些gulp插件,abcd这些命名只是用来举个例子 a = require('gulp-a'), b = require('gulp-b'), c = require('gulp-c'), d = require('gulp-d'), e = require('gulp-e'), f = require('gulp-f'), g = require('gulp-g'), //更多的插件... z = require('gulp-z'); 当我们需要加载的插件很多时，我们的 gulpfile.js 里的开头会很长很长，看起来不舒服。 建议使用 gulp-load-plugins, 它并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件。 123var gulp = require('gulp');//加载gulp-load-plugins插件，并马上运行它var plugins = require('gulp-load-plugins')(); 假如要使用gulp-rename和gulp-ruby-sass这两个插件的时候，就可以使用 plugins.rename 和plugins.rubySass 来代替了,也就是原始插件名去掉 gulp-前缀 ，之后再转换为 驼峰命名。实质上 gulp-load-plugins 是为我们做了如下的转换12plugins.rename = require('gulp-rename');plugins.rubySass = require('gulp-ruby-sass'); 重命名使用 gulp-rename1npm install --save-dev gulp-rename 用来重命名文件流中的文件。之前有提到，用 gulp.dest() 方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用gulp-rename插件来改变文件流中的文件名。12345678910var gulp = require('gulp'), rename = require('gulp-rename'), uglify = require("gulp-uglify"); gulp.task('rename', function () &#123; gulp.src('js/jquery.js') .pipe(uglify()) //压缩 .pipe(rename('jquery.min.js')) //会将jquery.js重命名为jquery.min.js .pipe(gulp.dest('js'));&#125;); 文件合并使用gulp-concat1npm install gulp-concat --save-dev 用来把多个文件合并为一个文件,我们可以用它来合并 js 或 css 文件等，这样就能减少页面的 http请求数了, 是一个提高页面加载效率的很不错的办法12345678var gulp = require('gulp'), concat = require("gulp-concat"); gulp.task('concat', function () &#123; gulp.src('js/*.js') //要合并的文件 .pipe(concat('all.js')) // 合并匹配到的js文件并命名为 "all.js" .pipe(gulp.dest('dist/js'));&#125;); 自动刷新使用 browser-sync 插件1npm install browser-sync --save-dev 当代码变化时，它可以帮我们自动刷新页面 本篇博客参考了前端构建工具gulpjs的使用介绍及技巧, 以及我自己的理解，下一步学习 WebPack~ ٩(๑❛ᴗ❛๑)۶]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>打包工具</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】实习半个月以来的收获和感想]]></title>
    <url>%2F2017%2F06%2F28%2F%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%AE%9E%E4%B9%A0%E5%8D%8A%E4%B8%AA%E6%9C%88%E4%BB%A5%E6%9D%A5%E7%9A%84%E6%94%B6%E8%8E%B7%E5%92%8C%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 首先来说说收获吧 收获初步掌握了 AngularJS 的用法和特性公司项目前端是使用的 AngularJS 这个框架，虽然不是当下热门的框架，比如 React ，Vue 等等，但是，作为前两年（前三年？）大火的框架，还是很值得一学的。 前几天写过一篇AngularJS的学习记录，入口： AngularJS 的学习记录 我顺带写了一个小 demo ，上传到了网盘，链接: 我的AngularJS练习Demo-MyApp 有兴趣的可以下载下来，一起学习，如果有代码的问题，欢迎在文章下面留言，或者给我发邮件~ 原型设计工具由Axure切换到了PS怎么说呢？应该是我技能树点歪了… 大二就对设计这方面比较感兴趣，大三开始确定自己作为前端开发的方向，其实和设计都有着千丝万缕的联系，然而，我还是想写代码，而不是转型到设计方向，因为，代码能改变的事情要多很多。我也不想放弃自己的兴趣爱好，所以，业余时间还是会钻一下设计。 一个巧合，让我认识了公司的设计师，之后，只要他晚上加班，我都会缠着他问设计方面的问题（平时都要上班）٩(๑❛ᴗ❛๑)۶ 每次都有种醍醐灌顶的感觉（他加班不多 TAT ），技术似乎有了些提升，看看对比效果 Axure: 实现某题目详情的页面（使用了antd的原型库） PhotoShop: 实现一个网站的首页 （我的原型图可不能提供下载链接♪(･ω･)ﾉ ） 图片太长，所以我调整了尺寸，完整的尺寸可以看这里 -&gt; (http://wx4.sinaimg.cn/mw690/006xRFa6gy1fh10x0fcpgj311g2bh4ig.jpg) 再附上一张这周交的人机交互的界面原型设计图如下，图片太长，就不展示了，有兴趣的话可以点击链接观看(http://wx1.sinaimg.cn/mw690/006xRFa6gy1fh10x52u5yj30uq2dpgu5.jpg) 项目开发，完成页面实现项目用的是 AngularJS 框架，简单来说，它就是一个 JS 框架，通过它的 指令 来控制页面的显示，有人说它是 MVC(model view controller) 模式，有人说他是 MVVM(model view viewModel) 模式,这里引用知乎上的一段话 mvc 的界面和逻辑关联紧密，数据直接从数据库读取。mvvm 的界面与 viewmode 是松耦合，界面数据从 viewmodel 中获取。 其实感觉要倾向于 MVVM 一些，我理解的还不是很深入，之后写篇关于这个的博客吧。AngularJS 里的 ng-Controller 异常强大，与页面的交互，与后端的数据对接，都是由它来进行中转。同时，AngularJS 很适合用来开发单一页面应用程序（SPAs: single page applications）简单的理解就是，以前，我们要改变页面的内容显示，要么重新加载一个页面，要么刷新当前页面，但是 单一页面应用程序则不同，它相当于是一个个组合起来的 &quot;容器&quot; ，假定当页面的 a 部分内容要改变时，其他容器的内容不会有刷新，只是包含 a 部分的容器里的内容换成 b 而已。 页面样式框架采用的是bootstrap，又是bootstrap… 总体来说，开发任务并不是很难（也许是因为我是实习生，只是给我安排了一些简单的任务），但是要做好，还是需要很细心地去做，我写的几个页面还是有很多不足的地方，师兄师姐们都很厉害，得多问问题！而且，得改掉工作中分心的坏毛病，这篇博客就是下午写的… 感想说实话，和我之前想像的不太一样 我以为会有一周的培训。 没有，给你几天时间，自己自学新的框架，有问题就问，熟悉之后，自己写个demo给师傅看，然后指出不足，自己再修改。 项目开发肯定是天天写新东西。 不是，真正原创的项目其实不多，20%左右？我不太清楚。由于公司之前积累了不少代码，很多功能代码都可以复用，改一些数据格式，样式，或者加些功能，就是一个新的项目 -&gt; 这就是传说中的轮子。。。 互联网公司，肯定天天加班。 也不是，这是看情况而定的，而且，属于员工自愿进行。当项目任务很紧急的时候，自然是要加班的，平常，其实还好，不过我还是愿意自己加班（要学的东西太多了，回到公寓里根本没法儿学，有种公司是图书馆，公寓是宿舍的感觉… 加班肯定是有各种福利的，有加班费，免费晚餐，报销车费。 很气，这个其实可以有，但是公司没有。。。没有加班费，得自己定外卖（要是人多，凑够了100多，可以让报销），车费？自己找小黄车￣へ￣ （关于加班免费提供晚餐的事，我向公司的人事建议过，不造有没有用。。。） 最后来上海也快半个月了，从刚来的时候，要买很多东西（一瓶红牛16 Σ(っ°Д°;)っ）喊着“魔都，魔都，真的是魔都”；到现在慢慢熟悉了这里的生活，发现了 神器 饿了么 ，自己买了电饭煲，周末去菜市场买菜，煮面（第一次用电饭煲煮面，味道还行）。慢慢地，觉得也还好，公寓的房东，保安人也都不错。 加油吧，可以在魔都活下去了~(๑╹◡╹)ﾉ”””]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS浅谈]]></title>
    <url>%2F2017%2F06%2F26%2FAngularJS%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” AnjularJS AngularJS 通过新的属性和表达式扩展了 HTML。AngularJS 可以构建一个单一页面应用程序（SPAs：Single Page Applications）。 基础 ng-app=” “ 定义angularJS的使用范围；指令告诉 AngularJS，&lt;div&gt; 元素是 AngularJS 应用程序 的 “所有者”。一个网页可以包含多个运行在不同元素中的 AngularJS 应用程序。 ng-init=”变量=值;变量=’值’” 初始化变量的值，有多个变量时，中间用分号隔开； ng-model=”变量” 定义变量名； ng-bind=”变量” 绑定变量名，获取该变量的数据。这里的变量就是第3条的变量名。但是一般都用双重花括号来获取变量的值 。 AngularJS 表达式写在双大括号内。AngularJS 表达式 很像 JavaScript 表达式：它们可以包含文字、运算符和变量。 AngularJS 是一个 JavaScript 框架。它可通过 &lt;script&gt; 标签添加到 HTML 页面。AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。 AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。 AngularJS 可以克隆和重复 HTML 元素。 AngularJS 可以隐藏和显示 HTML 元素。 AngularJS 可以在 HTML 元素”背后”添加代码。 AngularJS 支持输入验证。 AngularJS 应用 AngularJS 模块（Module） 定义了 AngularJS 应用。 AngularJS 控制器（Controller） 用于控制 AngularJS 应用。 ng-app指令定义了应用, ng-controller 定义了控制器。 提示：使用 ng-init 不是很常见 AngularJS 表达式 与 JavaScript 表达式类似于 JavaScript 表达式，AngularJS 表达式可以包含字母，操作符，变量。 与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中。 与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常。 与 JavaScript 表达式不同，AngularJS 表达式支持过滤器。 AngularJS 完美支持数据库的 CRUD（增加 Create 、读取 Read 、更新 Update、删除 Delete ）应用程序。把实例中的对象想象成数据库中的记录。 ng-model 指令ng-model 指令 绑定 HTML 元素 到应用程序数据。 ng-model 指令也可以： 为应用程序数据提供类型验证（number、email、required）。 为应用程序数据提供状态（invalid、dirty、touched、error）。 为 HTML 元素提供 CSS 类。 绑定 HTML 元素到 HTML 表单。 注意： 1. ng-model 是用于表单元素的，支持 **双向绑定** 。对普通元素无效； 2. ng-bind 用于普通元素，不能用于表单元素，应用程序单向地渲染数据到元素； 3. 当 ng-bind 和 `双重大括号` 同时使用时，ng-bind 绑定的值覆盖该元素的内容。 4. 验证用户输入, 提示信息会在 ng-show 属性返回 true 的情况下显示。 5. 应用状态 ng-model 指令可以为应用数据提供状态值(invalid, dirty, touched, error): $valid: true (如果输入的值是合法的则为 true)。 $invalid: true (如果输入的值是合法的则为 true)。 $pristine: 表单没有填写记录 $dirty: false (如果值改变则为 true)。myForm.user.$dirty $touched: true (如果通过触屏点击则为 true)。 $error: js对象，有如下几个值，使用方法：`&lt;span ng-show=&quot;myForm.email.$error.email&quot;&gt;非法的邮箱。&lt;/span&gt;` email max maxlength min minlength number pattern required url ng-model 指令根据表单域的状态添加/移除以下类： ng-empty ng-not-empty ng-touched ng-untouched ng-valid ng-invalid ng-dirty ng-pending ng-pristine 自定义指令123456// 自定义指令app.directive("aco", function() &#123; return &#123; template: "&lt;h1&gt;Hello ,我是Aco~&lt;/h1&gt;" &#125;;&#125;); 加 restrict 值 以来打到不同的要求restrict 值可以是以下几种: E 作为元素名使用 A 作为属性使用 C 作为类名使用 M 作为注释使用(注意加上`replace : true,`) restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。 AngularJS Scope(作用域)(模型层)当在控制器中添加 $scope 对象时，视图 (HTML) 可以获取了这些属性。视图中，你不需要添加 $scope 前缀, 只需要添加属性名即可，如： 双括号内部 提供变量名就行。 Scope 概述AngularJS 应用组成如下： View(视图), 即 HTML。 Model(模型), 当前视图中可用的数据。如果你修改了视图，模型和控制器也会相应更新 Controller(控制器), 即 JavaScript 函数，可以添加或修改属性。 scope 是模型。scope 是一个 JavaScript 对象，带有属性和方法，这些属性和方法可以在视图和控制器中使用。 根作用域 所有的应用都有一个 $rootScope，它可以作用在 ng-app 指令包含的所有 HTML 元素中。$rootScope 可作用于整个应用中。是各个 controller 中 scope 的桥梁。用 rootscope 定义的值，可以在各个 controller 中使用。 创建控制器时，将 $rootScope 作为参数传递，可在应用中使用： AngularJS 控制器（控制层）ng-controller 指令定义了应用程序控制器。控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建。 控制器的 $scope （相当于作用域、控制范围）用来保存AngularJS Model(模型)的对象。ng-model 指令绑定输入域到控制器的属性（firstName 和 lastName）。 12345678var app = angular.module('myApp', []);app.controller('personCtrl', function($scope) &#123; $scope.firstName = "John"; $scope.lastName = "Doe"; $scope.fullName = function() &#123; return $scope.firstName + " " + $scope.lastName; &#125;&#125;); AngularJS 过滤器 过滤器可以使用一个管道字符（|）添加到表达式和指令中。 AngularJS 过滤器可用于转换数据： 过滤器 描述 currency 格式化数字为货币格式。 filter 从数组项中选择一个子集。 lowercase 格式化字符串为小写。 orderBy 根据某个表达式排列数组。 uppercase 格式化字符串为大写。 向指令添加过滤器过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中。orderBy 过滤器根据表达式排列数组： 过滤输入输入过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中，该过滤器后跟一个冒号和一个模型名称。filter 过滤器从数组中选择一个子集： 1234567&lt;div ng-app="myApp" ng-controller="namesCtrl"&gt; &lt;p&gt;&lt;input type="text" ng-model="test"&gt;&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat="x in names | filter:test | orderBy:'country'"&gt; &#123;&#123; (x.name | uppercase) + ', ' + x.country &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; uppercase，lowercase 大小写转换 12&#123;&#123; "lower cap string" | uppercase &#125;&#125; // 结果：LOWER CAP STRING&#123;&#123; "TANK is GOOD" | lowercase &#125;&#125; // 结果：tank is good date 格式化 1&#123;&#123;1490161945000 | date:"yyyy-MM-dd HH:mm:ss"&#125;&#125; // 2017-03-22 13:52:25 number 格式化（保留小数） 1&#123;&#123;149016.1945000 | number:2&#125;&#125; currency 货币格式化 12&#123;&#123; 250 | currency &#125;&#125; // 结果：$250.00&#123;&#123; 250 | currency:"RMB ￥ " &#125;&#125; // 结果：RMB ￥ 250.00 filter 查找输入过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中，该过滤器后跟一个冒号和一个模型名称。filter 过滤器从数组中选择一个子集 12345// 查找name为iphone的行&#123;&#123; [&#123;"age": 20,"id": 10,"name": "iphone"&#125;, &#123;"age": 12,"id": 11,"name": "sunm xing"&#125;, &#123;"age": 44,"id": 12,"name": "test abc"&#125; ] | filter:&#123;'name':'iphone'&#125; &#125;&#125; limitTo 截取 12&#123;&#123;"1234567890" | limitTo: 6&#125;&#125; // 从前面开始截取6位&#123;&#123;"1234567890" | limitTo: -4&#125;&#125; // 从后面开始截取4位 orderBy 排序 默认正序 asc ,倒序添加-负号 1234567891011 // 根id降序排&#123;&#123; [&#123;"age": 20,"id": 10,"name": "iphone"&#125;, &#123;"age": 12,"id": 11,"name": "sunm xing"&#125;, &#123;"age": 44,"id": 12,"name": "test abc"&#125; ] | orderBy:'-id' &#125;&#125; // 根据id升序排&#123;&#123; [&#123;"age": 20,"id": 10,"name": "iphone"&#125;, &#123;"age": 12,"id": 11,"name": "sunm xing"&#125;, &#123;"age": 44,"id": 12,"name": "test abc"&#125; ] | orderBy:'id' &#125;&#125; 8.自定义过滤器12345app.filter('reverse', function() &#123; //可以注入依赖 return function(text) &#123; return text.split("").reverse().join(""); &#125;&#125;); AngularJS 服务(Service) $location 服务，它可以返回当前页面的 URL 地址。$scope.myUrl = $location.absUrl();,$location 服务是作为一个参数传递到 controller 中。如果要使用它，需要在 controller 中定义。 为什么使用服务? 在很多服务中，比如 $location 服务，它可以使用 DOM 中存在的对象，类似 window.location 对象，但 window.location 对象在 AngularJS 应用中有一定的局限性。AngularJS 会一直监控应用，处理事件变化， AngularJS 使用 $location 服务比使用 window.location 对象更好。因为这些服务可以获取到 Angular 应用声明周期的每一个阶段，并且和$watch 整合，让 Angular 可以监控应用，处理事件变化。普通的DOM对象则不能在Angular应用声明周期中和应用整合。 目录 window.location $location.service 目的 允许对当前浏览器位置进行读写操作 允许对当前浏览器位置进行读写操作 API 暴露一个能被读写的对象 暴露jquery风格的读写器 是否在AngularJS应用生命周期中和应用整合 否 可获取到应用声明周期内的每一个阶段，并且和$watch整合 是否和HTML5 API的无缝整合 否 是（对低级浏览器优雅降级） 和应用的上下文是否相关 否，window.location.path 返回 “/docroot/actual/path” 是，$location.path() 返回 “/actual/path” $http服务(重点) : 是 AngularJS 中的一个核心服务，用于读取远程服务器的数据。 123456789101112var app = angular.module('myApp', []); app.controller('siteCtrl', function($scope, $http) &#123; $http(&#123; method: 'GET', url: 'http://139.199.7.254:8080/AcoTest/person.php' &#125;).then(function successCallback(response) &#123; $scope.names = response.data.person; &#125;, function errorCallback(response) &#123; // 请求失败执行代码 &#125;);&#125;); 自定义服务 12345678910111213141516var app = angular.module('myApp', []);app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;);app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;;&#125;]);app.controller('myCtrl', function($scope) &#123; $scope.counts = [255, 251, 200];&#125;); AngularJS Select(选择框)在 AngularJS 中我们可以使用 ng-option 指令来创建一个下拉列表，列表项通过对象和数组循环输出。1234&lt;select ng-init="selectedName = names[0]" ng-model="selectedName" ng-options="x for x in names"&gt;&lt;/select&gt;&lt;!--使用对象型的数据源--&gt;&lt;select ng-model="selectedCar" ng-options="y.brand for (x,y) in cars"&gt;&lt;/select&gt; 也可以使用ng-repeat : 123&lt;select&gt; &lt;option ng-repeat="x in names"&gt;&#123;&#123;x&#125;&#125;&lt;/option&gt;&lt;/select&gt; 但是，使用 ng-options 时选项是一个对象，而使用 ng-repeat 时选项是一个字符串，因此，使用 ng-options 更好，也会更灵活。 AngularJS 表格ng-repeat 无敌 AngularJS SQL 需要连接数据库，服务器，之后再测试 AngularJS HTML DOM ng-disabled 指令绑定应用程序数据 “mySwitch” 到 HTML 的 disabled 属性。 ng-show 指令隐藏或显示一个 HTML 元素。true 为显示，false 为隐藏。ng-show 指令也可以根据 value 的值来显示（隐藏）HTML 元素。eg: 123&lt;div ng-app="" ng-init="hour=13"&gt; &lt;p ng-show="hour &gt; 12"&gt;我是可见的。&lt;/p&gt;&lt;/div&gt; ng-hide 指令用于隐藏或显示 HTML 元素。true 为隐藏，false 为显示。反过来就行 AngularJS 事件 ng-click 指令: 定义了 AngularJS 点击事件。 AngularJS 模块 创建模块 var app = angular.module(&quot;myApp&quot;, []); 在模块定义中 [] 参数用于定义模块的依赖关系。中括号[]表示该模块没有依赖，如果有依赖的话会在中括号写上依赖的模块名字。 添加控制器 123456789101112&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&#123;&#123; firstName + " " + lastName &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = angular.module("myApp", []); app.controller("myCtrl", function($scope) &#123; $scope.firstName = "John"; $scope.lastName = "Doe"; &#125;);&lt;/script&gt; 添加指令：可以使用内置的指令，也可以自己创建指令，上面有提到过 模块和控制器包含在 JS 文件中，eg : “myApp.js” 包含了应用模块的定义程序， “myCtrl.js” 文件包含了控制器： 函数会影响到全局命名空间 JavaScript 中应避免使用全局函数。因为他们很容易被其他脚本文件覆盖。 AngularJS 模块让所有函数的作用域在该模块下，避免了该问题。 6.对于 HTML 应用程序，通常建议把所有的脚本都放置在 &lt;body&gt; 元素的最底部。 在我们的实例中，AngularJS 在 &lt;head&gt; 元素中被加载，因为对 angular.module 的调用只能在库加载完成后才能进行。(不理解，我试过，放在页面底部也可以) AngularJS 表单见例子 AngularJS 表单是输入控件的集合。 ng-switch, ng-switch-when 指令根据单选按钮的选择结果显示或隐藏 HTML 区域。 AngularJS 输入验证AngularJS 表单和控件可以提供验证功能，并对用户输入的非法数据进行警告。 Note 客户端的验证不能确保用户输入数据的安全，所以服务端的数据验证也是必须的。 AngularJS APIAPI 意为 Application Programming Interface（应用程序编程接口）。 AngularJS 全局 APIAngularJS 全局 API 用于执行常见任务的 JavaScript 函数集合，如：比较对象, 迭代对象, 转换对象全局 API 函数使用 angular 对象进行访问。 angular.lowercase() 转换字符串为小写 angular.uppercase() 转换字符串为大写 angular.isString() 判断给定的对象是否为字符串，如果是返回 true。 angular.isNumber() 判断给定的对象是否为数字，如果是返回 true。 AngularJS 包含在 AngularJS 中，你可以在 HTML 中包含 HTML 文件。1&lt;div ng-include="'runoob.htm'"&gt;&lt;/div&gt; 跨域包含默认情况下， ng-include 指令不允许包含其他域名的文件。如果你需要包含其他域名的文件，你需要设置域名访问白名单：12345678910&lt;div ng-include="'http://c.runoob.com/runoobtest/angular_include.php'"&gt;&lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', [])app.config(function($sceDelegateProvider) &#123; $sceDelegateProvider.resourceUrlWhitelist([ 'http://c.runoob.com/runoobtest/**' ]);&#125;);&lt;/script&gt; 此外，还需要设置服务端允许跨域访问，Access-Control-Allow-Origin: * 设置方法可参考：PHP Ajax 跨域问题最佳解决方案。 AngularJS 动画AngularJS 提供了动画效果，可以配合 CSS 使用。AngularJS 使用动画需要引入 angular-animate.min.js 库。1&lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular-animate.min.js"&gt;&lt;/script&gt; 还需在应用中使用模型 ngAnimate：(如果应用已经设置了应用名，可以把 ngAnimate 直接添加在模型中：)1&lt;body ng-app="ngAnimate"&gt; 1var app = angular.module('myApp', ['ngAnimate']); 应用中动画不宜太多，但合适的使用动画可以增加页面的丰富性，也可以更易让用户理解。 ngAnimate 模型可以添加或移除 class 。ngAnimate 模型并不能使 HTML 元素产生动画，但是 ngAnimate 会监测事件，类似隐藏显示 HTML 元素 ，如果事件发生 ngAnimate 就会使用预定义的 class 来设置 HTML 元素的动画。AngularJS 添加/移除 class 的指令: ng-show ng-hide ng-class ng-view ng-include ng-repeat ng-if ng-switch ng-show 和 ng-hide 指令用于添加或移除 ng-hide class 的值。其他指令会在进入 DOM 会添加 ng-enter 类，移除 DOM 会添加 ng-leave 属性。当 HTML 元素位置改变时，ng-repeat 指令同样可以添加 ng-move 类 。此外， 在动画完成后，HTML 元素的类集合将被移除。例如： ng-hide 指令会添加一下类： ng-animate ng-hide-animate ng-hide-add (如果元素将被隐藏) ng-hide-remove (如果元素将显示) ng-hide-add-active (如果元素将隐藏) ng-hide-remove-active (如果元素将显示) AngularJS 依赖注入wiki 上的解释是： 依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。 该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖 一句话 — 没事你不要来找我，有事我会去找你。 AngularJS 提供很好的依赖注入机制。以下5个核心组件用来作为依赖注入： value factory service provider constant valueValue 是一个简单的 javascript 对象，用于向控制器传递值（配置阶段）：12// 创建 value 对象 "defaultInput" 并传递数据mainApp.value("defaultInput", 5); factoryfactory 是一个函数用于返回值。在 service 和 controller 需要时创建。通常我们使用 factory 函数来计算或返回值。12345678910111213141516// 创建 factory "MathService" 用于两数的乘积 provides a method multiply to return multiplication of two numbersmainApp.factory('MathService', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b &#125; return factory;&#125;); // 在 service 中注入 factory "MathService"mainApp.service('CalcService', function(MathService)&#123; this.square = function(a) &#123; return MathService.multiply(a,a); &#125;&#125;); providerAngularJS 中通过 provider 创建一个 service、factory等(配置阶段)。Provider 中提供了一个 factory 方法 get()，它用于返回 value/service/factory。12345678910111213141516171819202122232425262728// 使用 provider 创建 service 定义一个方法用于计算两数乘积mainApp.config(function($provide) &#123; $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;);&#125;);mainApp.service('CalcService', function(MathService)&#123; this.square = function(a) &#123; return MathService.multiply(a,a); &#125;&#125;); mainApp.controller('CalcController', function($scope, CalcService, defaultInput) &#123; $scope.number = defaultInput; $scope.result = CalcService.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService.square($scope.number); &#125;&#125;); constantconstant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的。1mainApp.constant("configParam", "constant value"); 一个对别人有依赖的东西，它想要单独测试，就需要在依赖项齐备的情况下进行。如果我们在运行时注入，就可以减少这种依赖 参数由定义方决定 与import还不完全一样 AngularJS 路由AngularJS 路由允许我们通过不同的 URL 访问不同的内容。通过 AngularJS 可以实现多视图的单页Web应用（single page web application，SPA）。通常我们的URL形式为 http://runoob.com/first/page，但在单页Web应用中 AngularJS 通过 # + 标记 实现，例如： http://runoob.com/#/first http://runoob.com/#/second http://runoob.com/#/third 需要载入1&lt;script src="http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>学习记录</tag>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Css回顾】你还记得哪些？]]></title>
    <url>%2F2017%2F06%2F07%2F%E3%80%90Css%E5%9B%9E%E9%A1%BE%E3%80%91%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 回顾CSS Positioning(定位)Static 定位 HTML元素的默认值，即没有定位，元素出现在正常的流中。 静态定位的元素不会受到 top, bottom, left, right影响。 Fixed 定位 元素的位置相对于浏览器窗口是固定位置。 即使窗口是滚动的它也不会移动： 注意： Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持. Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。 Relative 定位 相对定位元素的定位是相对其正常位置。可以移动的相对定位元素的内容和相互重叠的元素，它原本所占的空间不会改变。 相对定位元素经常被用来作为绝对定位元素的容器块。 即使相对定位元素的内容是移动,预留空间的元素仍保存在正常流动。 Absolute 定位 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;; solutely定位使元素的位置与文档流无关，因此不占据空间。 Absolutely定位的元素和其他元素重叠。 重叠的元素 元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素 z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面） 一个元素可以有正数或负数的堆叠顺序： 空元素内部使用伪元素生成的内容,是真实的吗？ 不真实，content属性动态生成的内容是纯粹的装饰而已，虚假的表象。是不被:empty伪类认可的，选择器依然认为这是个空元素。（所以才被称为伪元素…）链接：CSS之before, after伪元素特性表现两则 不要在属性值与单位之间留有空格 （如：margin-left: 20 px ），正确的写法是 margin-left: 20px 。 多重样式将层叠为一个样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。层叠次序当同一个 HTML 元素被不止一个样式定义时，会使用哪个样式呢？一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。 1 浏览器缺省设置 2 外部样式表 3 内部样式表（位于 `&lt;head&gt;` 标签内部） 4 内联样式（在 HTML 元素内部） 因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。Remark提示:如果你使用的外部文件样式在 &lt;head&gt;中也定义了该样式，则内部样式表会取代外部文件的样式。 CSS 背景属性用于定义HTML元素的背景CSS 属性定义背景效果: background-color background-image： 可以加载多幅图片，属性设置用逗号隔开 #example1 { background-image: url(img_flwr.gif), url(paper.gif); background-position: right bottom, left top; background-repeat: no-repeat, repeat; padding: 15px; } background-repeat： repeat 背景图像将向垂直和水平方向重复。这是默认 repeat-x 只有水平位置会重复背景图像 repeat-y 只有垂直位置会重复背景图像 no-repeat background-image不会重复 inherit 指定background-repeat属性设置应该从父元素继承 background-attachment： scroll 背景图片随页面的其余部分滚动。这是默认 fixed 背景图像是固定的 inherit 指定background-attachment的设置应该从父元素继承 background-position: 取值如下，如果仅指定一个关键字，其他值将会是&quot;center&quot; left top left center left bottom right top right center right bottom center top center center center bottom x% y% 第一个值是水平位置，第二个值是垂直。左上角是0％0％。右下角是100％100％。如果仅指定了一个值，其他值将是50％。 。默认值为：0％0％ xpos ypos 第一个值是水平位置，第二个值是垂直。左上角是0。单位可以是像素（0px0px）或任何其他 CSS单位。如果仅指定了一个值，其他值将是50％。你可以混合使用％和positions inherit 指定background-position属性设置应该从父元素继承 简写的顺序也是如此, eg : body {background:#ffffff url(&#39;img_tree.png&#39;) no-repeat right top;} 以上属性无需全部使用 大多数浏览器的默认行高约为110%至120%vertical-align属性设置一个元素的垂直对齐baseline 默认。元素放置在父元素的基线上。 sub 垂直对齐文本的下标。 super 垂直对齐文本的上标 top 把元素的顶端与行中最高元素的顶端对齐 text-top 把元素的顶端与父元素字体的顶端对齐 middle 把此元素放置在父元素的中部。 bottom 把元素的顶端与行中最低的元素的顶端对齐。 text-bottom 把元素的底端与父元素字体的底端对齐。 length % 使用 &quot;line-height&quot; 属性的百分比值来排列此元素。允许使用负值。 inherit 规定应该从父元素继承 vertical-align 属性的值。 在计算机屏幕上，sans-serif字体被认为是比serif字体容易阅读在CSS中，有两种类型的字体系列名称：通用字体系列 - 拥有相似外观的字体系统组合（如 “Serif” 或 “Monospace”）特定字体系列 - 一个特定的字体系列（如 “Times” 或 “Courier”） font-family 属性设置文本的字体系列font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。注意: 如果字体系列的名称超过一个字，它必须用引号，如Font Family：”宋体”。多个字体系列是用一个逗号分隔指明： 请务必使用正确的HTML标签 eg：&lt;h1&gt; - &lt;h6&gt;表示标题和&lt;p&gt;表示段落：字体大小的值可以是绝对或相对的大小。 绝对大小： 设置一个指定大小的文本 不允许用户在所有浏览器中改变文本大小 确定了输出的物理尺寸时绝对大小很有用 相对大小： 相对于周围的元素来设置大小 允许用户在浏览器中改变文字大小 Remark: 如果你不指定一个字体的大小，默认大小和普通文本段落一样，是16像素（16px=1em）。 用em来设置字体大小为了避免Internet Explorer 中无法调整文本的问题，许多开发者使用 em 单位代替像素。em的尺寸单位由W3C建议。 1em和当前字体大小相等。在浏览器中默认的文字大小是16px。 因此，1em的默认大小是16px。可以通过下面这个公式将像素转换为em：px/16=em body {font-size:100%;} h1 {font-size:2.5em;} h2 {font-size:1.875em;} p {font-size:0.875em;} font-weight 设置文本的粗细normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100 200 300 400 == normal 500 600 700 == bold 800 900 定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。 inherit 规定应该从父元素继承字体的粗细。 CSS盒子模型Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 当你指定一个CSS元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完全大小的元素，你还必须添加填充，边框和边距。 最终元素的总宽度计算公式是这样的： 总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距 元素的总高度最终计算公式是这样的： 总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 盒子模型标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。 网页中的盒子模型；我们常常要控制盒子模型的宽度width: w3c中的盒子模型的宽:包括margin+border+padding+width; width:margin*2+border*2+padding*2+width; height:margin*2+border*2+padding*2+height; iE中的盒子模型的width:也包括margin+border+padding+width; 上面的两个宽度相加的属性是一样的。不过在ie中content的宽度包括padding和border这两个属性； 例如一个盒子模型如下：margin:20px,border:10px,padding:10px;width:200px;height:50px; 如果用w3c盒子模型解释，那么这个盒子模型占用的 宽度为：20*2+10*2+10*2+200=280px; 高度：20*2+10*2+10*2+50=130px; 盒子的实际宽度大小为:10*2+10*2+200=240px; 实际高度：10*2+10*2+50=90px; 用ie的盒子模型解释 ：盒子在网页中占据的大小为20*2+200=240px; 高：20*2+50=90px; 盒子的实际大小为：宽度:200px, 高度:50px; 我们常常理解的盒子模型是w3c这样的盒子模型 border-style 属性可以有1-4个值：上 右 下 左；上 左右 下； 上下 左右 ； border-style: dotted solid double dashed; 上边框是 dotted 右边框是 solid 底边框是 double 左边框是 dashed border-style: dotted solid double; 上边框是 dotted 左、右边框是 solid 底边框是 double border-style: dotted solid; 上、底边框是 dotted 右、左边框是 solid border-style: dotted; 四面边框是 dotted 上面的例子用了border-style。然而，它也可以和border-width 、 border-color一起使用。 即使相对定位元素的内容是移动,预留空间的元素仍保存在正常流动。CSS 的 Float（浮动）会使元素向左或向右移动，其周围的元素也会重新排列。 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动元素之后的元素将围绕它。 浮动元素之前的元素将不会受到影响。 水平对齐中心对齐,使用margin属性 块元素可以把左，右页边距设置为&quot;自动&quot;对齐。 margin: auto; width: 70%; 如果宽度是100％，对齐是没有效果的。 Note: 1. 在IE8中使用margin:auto属性无法正常工作，除非声明 !DOCTYPE, 2. IE5中块元素有一个margin处理BUG。需要加上text-align: left; 使用position属性设置左，右对齐 元素对齐的方法之一是使用绝对定位： position:absolute; right:0px; width:300px; 使用float属性设置左，右对齐 使用float属性是对齐元素的方法之一： float:right; width:300px; Crossbrowser 兼容性问题类似这样的元素对齐时，预先确定margin和元素的填充，始终是一个好主意。这是为了避免在不同的浏览器中的可视化差异。IE8和早期有一个问题，当使用position属性时。如果一个容器元素（在本例中&lt;div class=&quot;container&quot;&gt;）指定的宽度，!DOCTYPE声明是缺失，IE8和早期版本会在右边增添17px的margin。这似乎是一个滚动的预留空间。使用position属性时始终设置在DOCTYPE声明中！ CSS vertical-alignCSS中的确是有vertical-align属性，但是它只对(X)HTML元素中拥有valign特性的元素才生效，例如表格元素中的&lt;td&gt;、&lt;th&gt;、&lt;caption&gt;等，而像&lt;div&gt;、&lt;span&gt;这样的元素是没有valign特性的 !!! CSS组合选择符包括各种简单选择符的组合方式。在 CSS3 中包含了四种组合方式: 1 后代选取器(以空格分隔)：后代选取器匹配所有值的元素的后代元素。 2 子元素选择器(以大于号分隔）：只能选择作为某元素子元素的元素。 3 相邻兄弟选择器（以加号分隔）：可选择紧接在另一元素后的元素，且二者有相同父元素。 4 后续兄弟选择器（以波浪线分隔）：后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。 font-size 的取值xx-small x-small small medium large x-large xx-large 把字体的尺寸设置为不同的尺寸，从 xx-small 到 xx-large。 默认值：medium。 smaller 把 font-size 设置为比父元素更小的尺寸。 larger 把 font-size 设置为比父元素更大的尺寸。 length 把 font-size 设置为一个固定的值。 % 把 font-size 设置为基于父元素的一个百分比值。 inherit 规定应该从父元素继承字体尺寸。 制作导航栏的时候 请务必指定 &lt;a&gt;元素在垂直导航栏的的宽度。如果省略宽度，IE6可能产生意想不到的效果。 CSS 伪类和伪元素：伪元素 :checked input:checked 选择所有选中的表单元素 :disabled input:disabled 选择所有禁用的表单元素 :empty p:empty 选择所有没有子元素的p元素 :enabled input:enabled 选择所有启用的表单元素 :first-of-type p:first-of-type 选择每个父元素是p元素的第一个p子元素 :in-range input:in-range 选择元素指定范围内的值 :invalid input:invalid 选择所有无效的元素 :last-child p:last-child 选择所有p元素的最后一个子元素 :last-of-type p:last-of-type 选择每个p元素是其母元素的最后一个p元素 :not(selector) :not(p) 选择所有p以外的元素 :nth-child(n) p:nth-child(2) 选择所有p元素的第二个子元素 :nth-last-child(n) p:nth-last-child(2) 选择所有p元素倒数的第二个子元素 :nth-last-of-type(n) p:nth-last-of-type(2) 选择所有p元素倒数的第二个为p的子元素 :nth-of-type(n) p:nth-of-type(2) 选择所有p元素第二个为p的子元素 :only-of-type p:only-of-type 选择所有仅有一个子元素为p的元素 :only-child p:only-child 选择所有仅有一个子元素的p元素 :optional input:optional 选择没有&quot;required&quot;的元素属性 :out-of-range input:out-of-range 选择指定范围以外的值的元素属性 :read-only input:read-only 选择只读属性的元素属性 :read-write input:read-write 选择没有只读属性的元素属性 :required input:required 选择有&quot;required&quot;属性指定的元素属性 :root root 选择文档的根元素 :target #news:target 选择当前活动#news元素(点击URL包含锚的名字) :valid input:valid 选择所有有效值的属性 :link a:link 选择所有未访问链接 :visited a:visited 选择所有访问过的链接 :active a:active 选择正在活动链接 :hover a:hover 把鼠标放在链接上的状态 :lang(language) p:lang(it) 为&lt;p&gt;元素的lang属性选择一个开始值 :focus input:focus 选择元素输入后具有焦点 :first-child p:first-child 选择器匹配属于任意元素的第一个子元素的 &lt;p&gt; 元素 伪元素，建议用:: ::first-letter p::first-letter 选择每个&lt;p&gt; 元素的第一个字母 ::first-line p::first-line 选择每个&lt;p&gt; 元素的第一行 ::before p::before 在每个&lt;p&gt;元素之前插入内容 ::after p::after 在每个&lt;p&gt;元素之后插入内容 伪类可以与 CSS 类配合使用： a.red:visited {color:#FF0000;} 但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。12:hover::first-child 注意：变更元素的显示类型 看该元素是如何显示，它是什么样的元素。例如：一个内联元素设置为display:block是不允许有它内部的嵌套块元素。 剪切元素的外形 clip ： 剪辑一个绝对定位的元素，唯一合法的形状值是：rect (top, right, bottom, left)12345678&lt;style&gt;img &#123; position:absolute; clip:rect(0px,60px,200px,0px);&#125;&lt;/style&gt;&lt;img src="w3css.gif" width="100" height="140" /&gt; 水平居中在IE5中的特殊处理123456789101112.container&#123; text-align:center;&#125;.center&#123; margin-left:auto; margin-right:auto; width:70%; background-color:#b0e0e6; text-align:left;&#125; 鼠标移上链接，出现方括号：12345678910111213a &#123; position: relative; display: inline-block; outline: none; text-decoration: none; color: #000; font-size: 32px; padding: 5px 10px;&#125;a:hover::before, a:hover::after &#123; position: absolute; &#125;a:hover::before &#123; content: "\5B"; left: -20px; &#125;a:hover::after &#123; content: "\5D"; right: -20px; &#125; 注意：在::before, ::after添加元素前，有一点需要注意的是，如果不需要内容仅配合样式属性做出效果，内容属性也不能为空，即 content:” “ 。否则，其他的样式属性一概不会生效。 CSS content 链接： CSS content内容生成技术以及应用]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Html回顾】系列]]></title>
    <url>%2F2017%2F06%2F05%2F%E3%80%90Html%E5%9B%9E%E9%A1%BE%E3%80%91%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” HTML关于 UTF-8 UTF-8 是标准写法，php 在 Windows 下边英文不区分大小写，所以也可以写成 utf-8。UTF-8 也可以把中间的”-“省略，写成 UTF8。一般程序都能识别，但也有例外（如下文），为了严格一点，最好用标准的大写”UTF-8”。 在数据库中只能使用utf8(MySQL) 在MySQL的命令模式中只能使用utf8，不能使用utf-8，也就是说在 PHP 程序中只能使用 set names utf8(不加小横杠)，如果你加了”-“此行命令将不会生效，但是在 PHP 中 header 时却要加上”-“，因为 IE 不认识没杠的utf8，原因见下文。PHP 中的 header： 1&lt;?php header('Content-Type: text/html; charset=UTF-8'); ?&gt; 总结： 除了在MySQL命令 mysql_query(set names utf8) 外一律用大写UTF-8。 后缀名选择：用 htm 还是用 html？ 推荐使用长后缀名 html 一些标签的使用，切记所有标签都需要闭合，不管是单体标签还是成对标签。尽管目前浏览器是识别有些标签不闭合的情况，但是取的最好的保证兼容性，使用闭合 标签写法要用小写字母（有些版本对大小写可认为相同，而xhtml中强制使用小写）HTML 属性常用引用属性值,属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。Remark提示: 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name=’John “ShotGun” Nelson’ 通常标签 &lt;strong&gt; 替换加粗标签 &lt;b&gt; 来使用, &lt;em&gt; 替换 &lt;i&gt;标签使用。然而，这些标签的含义是不同的：&lt;b&gt; 与&lt;i&gt; 定义粗体或斜体文本。&lt;strong&gt; 或者 &lt;em&gt;意味着你要呈现的文本是重要的，所以要突出显示。现今所有主要浏览器都能渲染各种效果的字体。不过，未来浏览器可能会支持更好的渲染效果。 对于非pre标签，浏览器会忽略源代码中的排版（省略了多余的空格和换行）以空格代替，段落的行数依赖于浏览器窗口的大小。如果调节浏览器窗口的大小，将改变段落中的行数。在标签&lt;a&gt; 中使用了href属性来描述链接的地址。默认情况下，链接将以以下形式出现在浏览器中： 一个未访问过的链接显示为蓝色字体并带有下划线。 访问过的链接显示为紫色并带有下划线。 点击链接时，链接显示为红色并带有下划线。 注意：如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示。 锚点：在HTML文档中插入ID:123456&lt;a id="tips"&gt;有用的提示部分&lt;/a&gt;在HTML文档中创建一个链接到"有用的提示部分(id="tips"）"：&lt;a href="#tips"&gt;访问有用的提示部分&lt;/a&gt;或者，从另一个页面创建一个链接到"有用的提示部分(id="tips"）"：&lt;a href="http://www.runoob.com/html/html-links.html#tips"&gt;访问有用的提示部分&lt;/a&gt; 养成好习惯，链接后面始终带上/假如这样书写链接：href=&quot;http://www.runoob.com/html&quot;，就会向服务器产生两次 HTTP 请求。这是因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href=&quot;http://www.runoob.com/html/&quot;。 html头部`&lt;base&gt;` - 定义了所有链接的URL 使用 `&lt;base&gt;` 定义页面中所有链接默认的链接目标地址。 `&lt;meta&gt;` - 提供了HTML文档的meta标记 使用 `&lt;meta&gt;` 元素来描述HTML文档的描述，关键词，作者，字符集等。 &lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt;, and &lt;base&gt;. HTML &lt;title&gt; 元素&lt;title&gt; 标签定义了不同文档的标题。&lt;title&gt; 在 HTML/XHTML 文档中是必须的。 `&lt;title&gt;` 元素: 定义了浏览器工具栏的标题 当网页添加到收藏夹时，显示在收藏夹中的标题 显示在搜索引擎结果页面的标题 每30秒中刷新当前页面:1&lt;meta http-equiv="refresh" content="30"&gt; 加载图像时， 假如某个 HTML 文件包含十个图像，那么为了正确显示这个页面，需要加载 11 个文件。加载图片是需要时间的，所以我们的建议是：慎用图片。注意: 加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的位置，浏览器无法加载图片，图像标签就会显示一个破碎的图片。这样的用户体验非常不好，因此，图片必须加上`alt`属性 - 在图片加载不出来时，显示图片的提示信息，告诉用户这是什么。 单元格边距(Cell padding)单元格间距(Cell spacing)增加单元格之间的距离,创建单元格内容与其边框之间的空白。 &lt;div&gt; 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt;table&gt; 元素进行文档布局不是表格的正确用法。&lt;table&gt; 元素的作用是显示表格化的数据。 &lt;span&gt; 用于对文档中的行内元素进行组合。&lt;span&gt; 标签没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。如果不对 &lt;span&gt; 应用样式，那么 &lt;span&gt; 元素中的文本与其他文本不会任何视觉上的差异。&lt;span&gt; 标签提供了一种将文本的一部分或者文档的一部分独立出来的方式。 虽然我们可以使用HTML table标签来设计出漂亮的布局，但是table标签是不建议作为布局工具使用的 - 表格不是布局工具。HTML 布局 - 有用的提示Tip: 使用 CSS 最大的好处是，如果把 CSS 代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局。如需学习更多有关 CSS 的知识，请访问我们的CSS 教程。Tip: 由于创建高级的布局非常耗时，使用模板是一个快速的选项。通过搜索引擎可以找到很多免费的网站模板（您可以使用这些预先构建好的网站布局，并优化它们）。Opera 或者 Internet Explorer 9 及之前的版本不支持 textarea 标签的 maxlength 属性。## 1600万种不同颜色三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。在下面的颜色表中你会看到不同的结果，从0到255的红色，同时设置绿色和蓝色的值为0,随着红色的值变化，不同的值都显示了不同的颜色。## Web安全色?数年以前，当大多数计算机仅支持 256 种颜色的时候，一系列 216 种 Web 安全色作为 Web 标准被建议使用。其中的原因是，微软和 Mac 操作系统使用了 40 种不同的保留的固定系统颜色（双方大约各使用 20 种）。我们不确定如今这么做的意义有多大，因为越来越多的计算机有能力处理数百万种颜色，不过做选择还是你自己。最初，216 跨平台 web 安全色被用来确保：当计算机使用 256 色调色板时，所有的计算机能够正确地显示所有的颜色。## 141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。下表列出了所有颜色的值，包括十六进制值。 提示: 17标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。点击其中一个颜色名称（或一个十六进制值）就可以查看与不同文字颜色搭配的背景颜色。：## HTML 字符实体HTML 中的预留字符必须被替换为字符实体。一些在键盘上找不到的字符也可以使用字符实体来替换。实体名称对大小写敏感！ HTML 统一资源定位器(Uniform Resource Locators)URL 是一个网页地址。URL可以由字母组成，如”runoob.com”，或互联网协议（IP）地址： 192.68.20.50。大多数人进入网站使用网站域名来访问，因为 名字比数字更容易记住。Web浏览器通过URL从Web服务器请求页面。 语法规则: `scheme://host.domain:port/path/filename` 说明: scheme - 定义因特网服务的类型。最常见的类型是 http host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 runoob.com :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 Scheme 访问 用于... http 超文本传输协议 以http:// 开头的普通网页不加密。 https 安全超文本传输协议 安全网页，加密所有信息交换。 ftp 文件传输协议 用于将文件下载或上传至网站。 file 您计算机上的文件。 通用声明123456&lt;!-- HTML5 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- HTML 4.01&lt;br&gt; --&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;!-- XHTML 1.0&lt;br&gt; --&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 一些简单的术语* 网页 ：由各种标记组成的一个页面就叫网页 . * 主页(首页) : 一个网站的起始页面或者导航页面 . * 标记: `&lt;p&gt;`称为开始标记 `&lt;/p&gt;`称为结束标记. 也叫标签.每个标签都规定好了特殊的含义。 * 元素：`&lt;p&gt;` 内容 `&lt;/p&gt;` 称为元素. * 属性： 给每一个标签所做的辅助信息。 * `xhtml`： 符合 `XML` 语法标准的 `HTML` 。 * `dhtml`：dynamic ,动态的。`javascript + css + html` 合起来的页面就是一个 `dhtml` * `http`：协议标准。用来规定客户端浏览器和服务端交互时数据的一个格式。 * SMTP: 邮件传输协议 * ftp: 文件传输协议. 如何将 HTML 转换为 XHTML添加一个 XHTML &lt;!DOCTYPE&gt; 到你的网页中添加 xmlns 属性添加到每个页面的html元素中。改变所有的元素为小写关闭所有的空元素修改所有的属性名称为小写所有属性值添加引号]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【第1期】系列收藏图片展]]></title>
    <url>%2F2017%2F06%2F02%2F%E3%80%90%E7%AC%AC1%E6%9C%9F%E3%80%91%E7%B3%BB%E5%88%97%E6%94%B6%E8%97%8F%E5%9B%BE%E7%89%87%E5%B1%95%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 第一期 就分享一些适合做桌面的美图吧，建议谷歌浏览器安装 远方New Tab 插件，每隔几小时，就会更新你的google浏览器背景图片，特别漂亮的那种，这里分享一些我比较喜欢的：]]></content>
      <categories>
        <category>pictures</category>
      </categories>
      <tags>
        <tag>图片展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【第1期】学习资料分享]]></title>
    <url>%2F2017%2F05%2F27%2F%E3%80%90%E7%AC%AC1%E6%9C%9F%E3%80%91%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 草稿中…过段时间就会发出来]]></content>
      <categories>
        <category>study-materials</category>
      </categories>
      <tags>
        <tag>学习资料</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017读书札记]]></title>
    <url>%2F2017%2F05%2F27%2F2017%E8%AF%BB%E4%B9%A6%E6%9C%AD%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 草稿中…过段时间就会发出来]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>札记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客第三方评论系统指南]]></title>
    <url>%2F2017%2F05%2F21%2F%E5%8D%9A%E5%AE%A2%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 多说关闭了，该选择哪种第三方评论呢？多说可以说是国内首屈一指的博客评论系统了，我在用WordPress写博客时就是用的它，与Disqus相比，对国内用户要友好很多 (Disqus需要翻墙才能使用，作为一枚程序猿，当然得会翻墙啦o(´^｀)o但是我不能保证想要评论我的博客的人也都能翻墙，所以还是暂时不用它了。不过，它的好处也有很多，本身就是专业做评论系统的，功能齐全，支持 ssl，响应化设计，界面美观。) 好了，接下来进入正题，选哪种比较好呢？我是个颜控(✪ω✪)所以评论系统的颜值很重要，功能也得强大一点，这里有两款我比较喜欢，一个是来自韩国的评论系统 –来必力，另一个就是国内的友言。 提供一个大佬对各种评论系统的详细介绍 —&gt; 第三方评论系统推荐 Bitcron 笔记 友言首先肯定是先介绍国内的友言，这里提供它的官网地址 友言：一个专业的网站社交评论系统 直接选择获取代码，手机端，PC端代码都是一样的1234&lt;!-- UY BEGIN --&gt;&lt;div id="uyan_frame"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js"&gt;&lt;/script&gt;&lt;!-- UY END --&gt; 有的主题内部有友言的选项，直接设置其为true就行,我使用的yilia主题没有，所以就得自己添加了，配置很简单，进入themes\yilia\layout\_partial文件夹下的article.ejs文件里加入如下代码 123456&lt;% if (!index &amp;&amp; post.comments &amp;&amp; theme.youyan==true)&#123; %&gt;&lt;!-- UY BEGIN --&gt; &lt;div id="uyan_frame"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js"&gt;&lt;/script&gt; &lt;!-- UY END --&gt;&lt;% &#125; %&gt; 然后在主题里的_config.yml里加上1youyan: true 一切就都OK了，评论样式如下： 是不是感觉似曾相识？没错，这可能是最像多说的评论系统。有评论统计、最新评论插件可以使用。有加网的分享按钮（Share this），友荐的猜你喜欢（Related posts），加上友言的评论系统，博客三件套齐活儿了。支持 QQ、新浪微博、人人、开心网账号登陆。界面很像 Disqus。 来必力这里也提供它的官网地址 欢迎来到来必力 先来看一看它的颜值(✪ω✪)可以提供10几种的登录方式，包括微信！可以发图片(可是不能发表情，这个稍微有点尴尬，希望官方日后能够添加这一功能) yilia主题依然没有配置来必力的选项，那么，我们来自己配 首先，去官网注册，应该不需要翻墙，应该…注册成功之后，选择City的免费版，安装，付费版有更多的功能，自己抉择~，然后就会出现获取代码，data-uid 这个值非常重要123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="你的特殊码"&gt; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt;&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 然后这是我的管理界面，可以很方便地改主题，管理评论 下面就是具体的配置过程,同样的，进入themes\yilia\layout\_partial文件夹下的article.ejs文件，然后添加1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; theme.livere_uid)&#123; %&gt; &lt;div id="lv-container" data-id="city" data-uid="&lt;%=theme.livere_uid%&gt;"&gt; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt; &lt;/div&gt;&lt;% &#125; %&gt; 然后在主题里的_config.yml里加上 1livere_uid: 你的特殊码 接下来就欢快地使用这两个颜值比较高的评论系统吧~[]~(￣▽￣)~*]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>多说</tag>
        <tag>第三方评论</tag>
        <tag>来必力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法介绍及进阶使用]]></title>
    <url>%2F2017%2F05%2F14%2FMarkDown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 什么是markdown？ Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 MarkDown简单语法应用 这些简单语法很多博客上都有，我就不意义赘述了，附上参考链接 http://www.jianshu.com/p/1e402922ee32/算了还是写进博客吧，免得新开页面~(^_−)☆直接看效果和例子-&gt; 1. 标题 –&gt; 例子 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 –&gt; 效果 一级标题二级标题三级标题四级标题五级标题六级标题 2. 列表分为有序列表和无序列表，用- + *实现，不过符号之后的空格不能少，-+*效果一样，但不能混合使用(列表快块要用就用一样的)，因混合是嵌套列表，内容可超长 2.1 无序列表 –&gt; 例子 1234- 无序列表- 无序列表- 无序列表- 无序列表：测试长文本，Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World (超长会自动换行) –&gt; 效果 无序列表 无序列表 无序列表 无序列表：测试长文本，Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World Hello World (超长会自动换行) 2.2 有序列表自己添加数字，如果无序会自动转换成有序 –&gt; 例子 123b. 有序列表5. 有序列表3. 有序列表 –&gt; 效果 有序列表 有序列表 有序列表 2.3 嵌套列表 –&gt; 例子 123456- 嵌套列表 + 嵌套列表 + 嵌套列表 - 嵌套列表 * 嵌套列表- 嵌套列表 –&gt; 效果 嵌套列表 嵌套列表 嵌套列表 嵌套列表 嵌套列表 嵌套列表 (hexo博客的markdown渲染不出来？。。。大家可以在markdown编辑器或者有支持markdown的插件里试一下，可以实现嵌套) 3. 引用这个简单，只需要在文本前加入 &gt; 这种尖括号（大于号）即可，如果想要多层签套，那么多加几个&gt;即可 –&gt; 例子 123&gt; Hello World!&gt;&gt; Hello World!&gt;&gt;&gt; Hello World! –&gt; 效果 Hello World! Hello World! Hello World! [注] 代码区块的引用，直接tab键就可以形成一个区块，里面的Markdown 语法都会作为文本显示 4. 图片与链接插入链接与插入图片的语法很像，区别在一个 !号图片为：![](){ImgCap}{/ImgCap}链接为：[]() 插入图片的地址需要图床，我用的是新浪微博相册的图床，右键辅复制图片URL地址即可。 4.1 图片 –&gt; 例子 1![提示信息](http://wx4.sinaimg.cn/mw690/006xRFa6gy1ffldjgxu9bj31hc0u0b29.jpg) –&gt; 效果 4.2 链接 –&gt; 例子 12[显示的文本](链接 "提示信息")[哔哩哔哩](www.bilibili.com) –&gt; 效果 哔哩哔哩 5. 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个** / __包含一段文本就是粗体的语法，用一个* / _包含一段文本就是斜体的语法。星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格 –&gt; 例子 1234567891011**Hello World**** Hello World **__Hello World__** HelloWorld ***Helloworld*_Hello World_ –&gt; 效果 Hello World Hello World Hello World HelloWorld Helloworld Hello World 6. 表格表格如果用markdown语法解决的话，超麻烦,后面优化里会有解决办法 –&gt; 例子 12345678910| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |header 1 | header 2 | header 3---|---|---row 1 col 1 | row 1 col 2 | row 2 col 3row 2 col 1 | row 2 col 2 | row 3 col 3 –&gt; 效果 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 header 1 header 2 header 3 row 1 col 1 row 1 col 2 row 2 col 3 row 2 col 1 row 2 col 2 row 3 col 3 7. 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` ` 把中间的代码包裹起来。 7.1 普通短文本代码 –&gt; 例子 1`Hello` –&gt; 效果 Hello 7.2 代码：段落代码每行文字前加4个空格或者1个Tab,当代码很长，用三个``` ``` –&gt; 例子 val s = &quot;hello Markdown&quot; println( s ) val s = &quot;hello Markdown&quot; println( s ) –&gt; 效果 val s = &quot;hello Markdown&quot; println( s ) val s = &quot;hello Markdown&quot; println( s ) 8. 分割线三个或更多-_*，必须单独一行，可含空格大标题: ===小标题: --- –&gt; 例子 123---***___ –&gt; 效果 MarkDown进阶 一句话，markdown支持html语法！！！这意味着什么？如果发现新功能，之后会计时更新补充(^_−)☆ 1. 支持基本的HTML标签图片居中利用center标签 –&gt; 例子 1&lt;center&gt;![提示信息](http://wx4.sinaimg.cn/mw690/006xRFa6gy1ffldjgxu9bj31hc0u0b29.jpg)&lt;/center&gt; –&gt; 效果 字体 –&gt; 例子 123456&lt;font face="黑体"&gt;我是黑体字&lt;/font&gt;&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face="黑体"&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; –&gt; 效果 我是黑体字我是微软雅黑我是华文彩云黑体Hello Worldnullgray 表格 –&gt; 例子 12345678910111213141516171819202122232425&lt;table&gt; &lt;caption&gt;实现markdown表格&lt;/caption&gt; &lt;thead&gt; &lt;td&gt;第一列&lt;/td&gt; &lt;td&gt;第二列&lt;/td&gt; &lt;td&gt;第三列&lt;/td&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; (应该是hexo的markdown渲染问题，原理上不应该显示那么大一片空白的，其他编辑器里可以正常显示) –&gt; 效果 实现markdown表格 第一列 第二列 第三列 1 2 3 1 2 3 1 2 3 注释 –&gt; 例子 1&lt;!-- 注释 --&gt; –&gt; 效果 2. 特殊一点的技巧索引超链：Reference方式索引，1 可以是任意字符 –&gt; 例子 1234[哔哩哔哩][1][Github][2][1]:www.bilibili.com[2]:www.github.com –&gt; 效果 哔哩哔哩Github 自动链接尖括号 –&gt; 例子 12&lt;http://www.baidu.com&gt;&lt;2973978759@qq.com&gt; –&gt; 效果 http://www.baidu.com&#50;&#x39;&#55;&#51;&#x39;&#x37;&#x38;&#55;&#x35;&#57;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d; 转义字符Markdown中的转义字符为\，转义的有： \ 反斜杠` 反引号* 星号_ 下划线{} 大括号[] 中括号() 小括号# 井号+ 加号- 减号. 英文句号! 感叹号 3. 支持导入css样式表这里只举两个例子 让你的文章可以显示QQ小表情导入一个css库即可 –&gt; 例子 12345678&lt;link href="https://afeld.github.io/emoji-css/emoji.css" rel="stylesheet"&gt;&lt;div class="em em-trollface" style=" height: 100px; width: 100px; background-color: red;"&gt;&lt;/div&gt; &lt;i class="em em-trollface"&gt;&lt;/i&gt; &lt;i class="em em-angry"&gt;&lt;/i&gt; &lt;i class="em em-apple"&gt;&lt;/i&gt; &lt;i class="em em-astonished"&gt;&lt;/i&gt; &lt;i class="em em-blush"&gt;&lt;/i&gt; &lt;i class="em em-confounded"&gt;&lt;/i&gt; –&gt; 效果 ### 页面显示CSS3的动画效果 –&gt; 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;style&gt;.test&#123; width:100px; height:100px; background:red; position:relative; animation:myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation:myfirst 5s linear 2s infinite alternate; /* Safari and Chrome: */ -webkit-animation:myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation:myfirst 5s linear 2s infinite alternate;&#125;@keyframes myfirst&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;div class="test"&gt;&lt;/div&gt; –&gt; 效果(hexo的渲染又出问题了，本地是显示正常的…因此我只能发个截图了，大家自己操作看效果).test{ width:100px; height:100px; background:red; position:relative; animation:myfirst 5s linear 2s infinite alternate; / Firefox: / -moz-animation:myfirst 5s linear 2s infinite alternate; / Safari and Chrome: / -webkit-animation:myfirst 5s linear 2s infinite alternate; / Opera: / -o-animation:myfirst 5s linear 2s infinite alternate;}@keyframes myfirst{ 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;}}@-moz-keyframes myfirst / Firefox /{ 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;}}@-webkit-keyframes myfirst / Safari and Chrome /{ 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;}}@-o-keyframes myfirst / Opera /{ 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;}}]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>语法教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日随笔]]></title>
    <url>%2F2017%2F05%2F01%2F%E6%AF%8F%E6%97%A5%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 用博客，记录下我灵光乍现的感想最新的，永远会在第一条~(使用withme日记本记录一些灵感，然后整理到博客上) 2017-6-20不勇敢，你什么都得不到。 不要总是去想象时间能倒退该有多好，那不可能，如果你不做出改变，那么，你就永远会处于劣势 当你遭遇失败，沮丧的时候，当你遭遇人生黑暗的阶段，当你被各种负面情绪所包围的时候，去太阳底下晒一晒，睡一觉吧，阳光会给你希望 2017-6-19永远不要等你准备好了再去做一件事，那样黄花菜都凉了，而且，你永远都不可能完全准备好，在实践中查缺补漏！在实践中进步！ 永远都不要放弃！ 2017-6-18人怎么可能什么都知道，重要的不是他知道多少，而是他的潜力，解决问题的能力与探索的欲望 会淹死的都是半吊子，实力强的根本无需担心 2017-6-16对自己的能力和定位要有一个清楚的认识 只想着用玩的心态去做事，是成功不了的 2017-6-13不要把时间浪费在无意义的事情上 不会的东西赶紧去学，去 2017-6-10有趣的灵魂 装在手机里电脑里的始终是别人的，装进头脑里的才是自己的！ 2017-6-9不要一直停留在语法层面上，要知道原理和本质 2017-6-6在父母面前，自己应该永远表现得像个孩子。 我要创造奇迹！ 2017-6-4实践再次证明，熬夜就是傻逼，效率超低，而且伤身体 唱歌和跑步可以缓解压力和紧张 2017-6-3做最真实的你，才能自由自在，掩饰的东西，一旦被揭露，将成为一场巨大的灾难 只是靠努力的话是远远不够的，因为你的对手也在努力，这是最基本的，还有比眼界，比气势，比能力，比合作…… 2017-6-1越是简单的事情，越敷衍，它所耗费的时间也就越长，认真对待，思考，才能快速地解决 在不同的地方，做不同的事，在图书馆就去应该好好学习，在宿舍就应该好好放松，两个混杂了，你是做不成事的 2017-5-29不要为了写博客而写博客，把你学到的写出来，就好 2017-5-27想遇见更好的人，你就必须先努力变得优秀，然后再变得更优秀 考验自己吧！成长吧！ 2017-5-25怎样才能帮助记忆，一味地重复复习是不行的，需要构建知识架构，即脑图， 根据节点来记忆是效果最好的 面试时如果你觉得面试官问的太简单了，那么你就应该自主的往深入扩展，如果你也简单答的话，那么你绝对过不了 2017-5-24相信自己，不要那么悲观，给自己信心，赢了就好，输了也无所谓，大不了再试一次 优秀的人，周围的人会让他更优秀，而弱小的人，没有人会去关心。这就是所谓的强者越强，弱者越弱的道理 2017-5-23认真对待你面对的问题与挑战，不能放弃，也不要急躁 不要走路玩手机，不要睡前看笔记，不要熬夜，这样的效率太低了，要学会调整自己的状态，在干劲满满的时候努力工作，走路，睡前就放松一下头脑，思考一些问题，唱唱歌，聊聊天，什么时候做什么事，让自己劳逸结合，始终处于最好的状态 2017-5-22率直，想要什么就说出来 2017-5-20不会的赶紧学，不会的赶紧补，要相信自己的能力和头脑，你可以在短时间内搞定的！ 学习 记忆新知识采用问答法，学完之后问自己会了什么，自己提问题，自己组织答案 2017-5-19事情要一件一件做，同时做两件事都做不好 2017-5-16开心的人在开心，而我在孤独地探索 跑步可以减压 2017-5-15我的进化之路 每天空闲时间把你当天以及之前学到的咀嚼一下，加强理解，不能只靠死记，要理解！理解！理解！ 从今天开始，重新做人，变成你理想中的自己 2017-5-13你需要知道你想要做什么，想去哪里，并做好准备，付出努力 有针对性的做事情，学会抓重点，找机会！ 2017-5-11理解至上，背诵来的东西是靠不住的 2017-5-10要知道自己想要什么，不要做浪费时间的事啊！ 向大神看齐，多关注你前进的领域的最新情况，情报很重要！很多时候能决定一次征途的成败 2017-5-9失败固然可怕，可是更可怕的是失败之后一蹶不振，完全不思考为什么失败，不去查缺补漏，不去及时修补自己的不足 实力是硬伤，实力不行，有机会也抓不住，赶紧增强实力！ 2017-5-8与其低效率地连续工作，还不如高效率地短期工作，要学会调整自己的状态。 无论做什么，认真地思考会得到更多的东西。 2017-5-7世界上绝大多数的失败，都是源于自己的不努力 自己手机的东西，要赶紧学到手啊，放在仓库里的东西，永远不是你的东西，装进头脑里的才是。 2017-5-6善待别人，也要善待自己 不要忘了你的梦想！ 2017-5-5刻意的去记一些东西，每天坚持锻炼自己的记忆力~ 机会有很多，然而，它只青睐有实力的人 2017-5-4不要忘了自己的梦想！ 机会有很多，然而它只青睐有实力的人。 多懂一些东西，多会一些技能，绝对会有好处的，在一些紧急关头会发挥意想不到的作用。这个世界，需要的是全面的人，专精虽好，可是有点狭隘了。 2017-5-3如果有人觉得你是SB，那么不管你做什么，如何证明自己，他都会觉得你是SB，所以，直接无视就行，我们不需要去讨好那些讨厌我们的人，没有意义。做好自己，过得开心，做你想做的事，和你想说的人说话，好好度过每一天，毕竟时间那么宝贵，过得不开心就可惜了~ (^し^) 2017-5-2刻意地去记忆一些东西，随时随地锻炼自己的记忆力。 如果你的作品都震撼不到自己，又谈何震撼到别人？ 2017-5-1专注的秘密就是不停的思考你正在做的事情，想着怎么做好它，想着想着自然而然就变得专注了。 —栋栋 情报很重要！！！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所有的悔恨,都源于弱小]]></title>
    <url>%2F2017%2F04%2F20%2F%E6%89%80%E6%9C%89%E7%9A%84%E6%82%94%E6%81%A8%E9%83%BD%E6%BA%90%E4%BA%8E%E5%BC%B1%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco ^(=w=)^~~ 记得是哪部动漫里有句很中二的话：弱小本身就是一种罪，弱小的人，连自己的死法都无从选择。我现在就深有体会。 现在大三下，从3月份开始，就准备找实习了，Web前端开发，投了很多简历，做了很多笔试，可是，就只有腾讯的过了，也许是运气吧 ( 当时一看，大部分都是C++的题目，本来感觉要GG的，没想到过了，但是，其他的都挂了…(ಥ_ಥ) ) 一面，问的不是很细，我也发挥出来超常的水平，跟面试官还蛮聊得来，一共40多分钟，有10几分钟是在聊天(^し^)，那是我第一次面试，总体来说真的是超常发挥了，面完后就回去等状态，等了一天，一直没结果，第三天早上，我醒来就看了一下状态，直接喊了一句：卧槽∑(っ°Д°;)っ，我到复试了!!! 当时真的是特别激动，然后卯足劲儿复习。 二面，面我的应该是技术主管吧，打断了我的自我介绍，就开始问项目，这方面我说的还不错，可是，算法方面我答的太差了，之前跟没有好好复习算法，问到快排，完全二叉树，都被问倒了，而这些本来应该是大二的时候就掌握好的，面试官没有问到数据库和操作系统的知识，要不然我会更加凌乱．．． 二面就挂在了这儿。腾讯梦结束 自从腾讯面完之后，我整个人都好像被抽空了一样，复习也打不起精神，一直在做一些无关紧要的事情： 比如搭这个博客，说实话半天足矣，我弄好之后，选主题，换主题，弄了半天，多说评论要下架了，选第三方评论，配置花了半天，各种不专心，弄了好久，时间花了那么多，学到的东西没多少，效率太低了。 也许是在逃避了，因为突然发现，自己好弱，好后悔之前没有好好努力, 所有的悔恨，都源于弱小。现在回想起来，为什么动漫里的主角能当主角呢？外表只是一个很小的方面，更主要的是主角们的实力，一个好的性格，加上强劲的实力，自然而然就会有伙伴，就会不断地进步。 所以，如果你不想被别人支配你的人生，如果你想变得更强，那么，——就快给我滚去学习啊！！！ 每天早上早起一个小时，学习的时候就好好学习，娱乐的时候就好好娱乐，各方面都得提高效率，动漫养肥了再看，这样既节约时间，又看的舒服…… 总之，时间不多了，好好努力，为秋招做准备！]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>随感</tag>
        <tag>还来得及</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github+hexo 搭建完全免费、实用的博客]]></title>
    <url>%2F2017%2F04%2F18%2F%E4%BD%BF%E7%94%A8github%20%2B%20hexo%20%E6%90%AD%E5%BB%BA%E5%AE%8C%E5%85%A8%E5%85%8D%E8%B4%B9%E3%80%81%E5%AE%9E%E7%94%A8%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[断剑重铸之日，骑士归来之时！ — 向着自由，向着未来出发Aco (๑╹◡╹)ﾉ””” 我的第一篇博客[TOC] 1，搭建环境准备 Node.js 的安装和准备 Git的安装和准备 gitHub账户的配置 1.1 配置Node.js环境 1.1.1下载Node.js安装文件：去官网选择合适的版本安装 Node.js官网 具体安装教程网上都有，提供两个教程链接吧菜鸟教程Node.js 安装配置CSDN博客NodeJS、NPM安装配置步骤(windows版本) 具体安装过程这里就不赘述了，安装完成之后，需要检查一下是否安装成功，打开命令行窗口（Win+R，输入cmd回车）在打开的命令行界面中，输入12node -vnpm -v 如果显示下图，则node.js安装完成，我们可以开始下一步了。 1.2 Git的安装和准备 1.2.1 区官网下载Git安装文件,选择一个合适的版本：Git Dowload 安装过程同样自己找教程，这里提供一个百度经验图文详解Windows下安装最新版Git同样，也需要检查一下1git --version 1.2.2 github账户的注册和配置 如果已经拥有账号，请跳过此步~如果没有，请接着看 1）Github注册打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。一定要确认注册，否则无法使用gh-pages！2）创建代码库登陆之后，点击页面右上角的加号，选择New repository： 新建一个名为yourname.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 几个注意的地方： 注册的邮箱一定要验证，否则不会成功！ 仓库名字必须是：username.github.io，其中username是你的用户名！ 3）代码库设置开启GitHub Pages功能，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 然后访问一下 yourname.github.io 这个网址就可以了 至此，git的安装和配置已经完成，我们进入下一部分~ 2，HeXo的安装和配置2.1 hexo安装 在自己认为合适的地方创建一个文件夹，这里我以D:\github\HeXo 为例子讲解，创建完成后，在命令行的窗口进入到该目录输入1npm install hexo-cli -g 可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。然后输入1npm install hexo --save 然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入：1hexo -v 如果你看到了如图文字，则说明已经安装成功了。 2.2 hexo的相关配置 2.2.1 初始化Hexo 接着上面的操作，输入：1hexo init 然后输入：1npm install 之后npm将会自动安装你需要的组件，只需要等待npm操作即可。继续操作，同样是在命令行中，输入：1hexo g 然后输入：1hexo s 然后会提示：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.在浏览器中打开http://localhost:4000/，你将会看到： 最后，输入1npm install hexo-deployer-git --save 安装一个扩展来支持git命令 到目前为止，Hexo在本地的配置已经全都结束了。下面会讲解怎样将Hexo与github page 联系起来 3, 将Hexo与github page 联系起来3.1 配置git个人信息如果你之前已经配置好git个人信息，请跳过这一个步骤 3.1.1 设置Git的user name和email：(如果是第一次的话) 输入注册时的用户名和邮箱12git config --global user.name "yourname"git config --global user.email "你注册时的邮箱@xx.com" 3.1.2 生成密钥 首先输入1cd ~/. ssh 检查本机是否已存在的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。输入:1ssh-keygen -t rsa -C "你注册时的邮箱@xx.com" 然后会提示是否需要密码，这个可设可不设，设了麻烦，不设不安全，自己抉择~最终会生成一个文件在用户目录下,打开用户目录,比如我的是C:\Users\热血绅士\\.ssh，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功，输入这个指令（就是git@github.com,不用改）1ssh -T git@github.com 注意：如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi Change-TheWorld! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 3.2 配置Deployment同样在_config.yml文件中，找到Deployment，然后按照如下修改：1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 这样就可以了,我之前配置的时候就是在这里吃了亏…我 repo 写的是https://github.com/Change-TheWorld/Change-TheWorld.github.io.git 结果博客上传过程中一直报错，下面我会介绍一下错误及解决办法 4，发布新建一篇博客，执行下面的命令：1hexo new post "MyFirstBlog" 这时候在我的 电脑的目录下 D:\github\HeXo\source_posts 将会看到 MyFirstBlog.md 文件用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成.部署命令： hexo g 生成静态文件 hexo d 发布12hexo g hexo d 当然你也可以执行下面的命令，相当于上面两条命令的效果，在部署前先生成1hexo d -g 部署成功后访问 你的地址，https://yourName.github.io,将可以看到生成的文章。 5，出现的错误及解决办法5.1 错误一 “ssh: connect to host github.com port 22: Connection timed out”错误 在连接github时，执行1ssh -T Git@github.com 命令时，出现”ssh: connect to host github.com port 22: Connection timed out” 解决办法：进入在存放公钥私钥(id_rsa和id_rsa.pub)的文件夹,比如我的就是C:\Users\热血绅士\\.ssh，新建config文件，不需要后缀名 用notepad++ 打开输入以下内容：123456Host github.comUser YourEmail@xx.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 user填入你注册时的邮箱，用户名也可以~再次执行ssh -T git@github.com时，会出现提示如下，回车yes即可。 5.2 错误二 “failed to connect to github.com port 443: Timed out” 一开始我尝试着设置1git config --global http.proxy socks5://192.168.192.136:8080 然并卵;改端口，然并卵…..后来我才发现我自己配置Deployment的时候repo写的是https://github.com/Change-TheWorld/Change-TheWorld.github.io.git 问题就出在这个地方,这是为什么呢？ git@github.com:yourname/yourname.github.io.git 与 https://github.com/Change-TheWorld/Change-TheWorld.github.io.git有什么区别吗？ 这里我提供一个github官方的文档解释github官方的文档解释github默认的是SSH方式，这样更快速，相对的操作也会麻烦一点，按照上面的配置，可以实现两种之间的转换.比如当你clone 一些资源的时候1git clone https://github.com/iissnan/hexo-theme-next themes/next 要改成1git clone git@github.com:iissnan/hexo-theme-next themes/next 6，与域名进行绑定6.1 首先，要申请一个域名，我的是在腾讯云上申请的，学生认证后免费试用一年的个人域名申请到了之后，进行域名的解析 如图第一行和第二行，就是将我的域名与github上的博客的主页相绑定，配置好之后，到github博客项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： ● 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me ● 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me ● 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 7，常用命令集合 hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写 hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： hexo s -g #生成并本地预览hexo d -g #生成并上传 8，发挥你的想象，开始你的博客之旅吧！以上~这就是我的第一篇博客，希望能够帮到大家]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>新手经历</tag>
        <tag>博客搭建</tag>
        <tag>HeXo</tag>
      </tags>
  </entry>
</search>